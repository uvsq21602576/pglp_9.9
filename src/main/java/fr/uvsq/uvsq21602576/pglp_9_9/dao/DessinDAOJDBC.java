package fr.uvsq.uvsq21602576.pglp_9_9.dao;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import fr.uvsq.uvsq21602576.pglp_9_9.dao.exceptions.ConnectionException;
import fr.uvsq.uvsq21602576.pglp_9_9.dao.exceptions.CreationObjetException;
import fr.uvsq.uvsq21602576.pglp_9_9.dao.exceptions.CreationTableException;
import fr.uvsq.uvsq21602576.pglp_9_9.dao.exceptions.DeletionException;
import fr.uvsq.uvsq21602576.pglp_9_9.dao.exceptions.DoublonException;
import fr.uvsq.uvsq21602576.pglp_9_9.dao.exceptions.InexistantException;
import fr.uvsq.uvsq21602576.pglp_9_9.dao.exceptions.InsertionException;
import fr.uvsq.uvsq21602576.pglp_9_9.dao.exceptions.JDBCException;
import fr.uvsq.uvsq21602576.pglp_9_9.dao.exceptions.LectureException;
import fr.uvsq.uvsq21602576.pglp_9_9.dao.exceptions.MetaDataException;
import fr.uvsq.uvsq21602576.pglp_9_9.dao.exceptions.MisAJourException;
import fr.uvsq.uvsq21602576.pglp_9_9.dao.exceptions.ModificationException;
import fr.uvsq.uvsq21602576.pglp_9_9.dao.exceptions.RechercheException;
import fr.uvsq.uvsq21602576.pglp_9_9.dao.exceptions.RemplissageStatementException;
import fr.uvsq.uvsq21602576.pglp_9_9.dao.exceptions.SuppressionException;
import fr.uvsq.uvsq21602576.pglp_9_9.exceptions.DejaExistantException;
import fr.uvsq.uvsq21602576.pglp_9_9.exceptions.DessinGlobalException;
import fr.uvsq.uvsq21602576.pglp_9_9.formes.Carre;
import fr.uvsq.uvsq21602576.pglp_9_9.formes.Cercle;
import fr.uvsq.uvsq21602576.pglp_9_9.formes.ComposantDessin;
import fr.uvsq.uvsq21602576.pglp_9_9.formes.Dessin;
import fr.uvsq.uvsq21602576.pglp_9_9.formes.Rectangle;
import fr.uvsq.uvsq21602576.pglp_9_9.formes.Triangle;

/**
 * Dao JDBC pour dessin.
 * @author Flora
 */
public class DessinDAOJDBC extends DAO<Dessin> {

    /**
     * URL pour la base de donnée.
     */
    private static final String DB_URL =
            "jdbc:derby:donneesPourDB\\jdbcDB;create=true";

    /**
     * Retourne la connexion à la base de donnée.
     * @return Connexion à la base de donnée
     * @throws ConnectionException En cas d'erreur à la connexion
     */
    private Connection getConnection() throws ConnectionException {
        try {
            return DriverManager.getConnection(DB_URL);
        } catch (SQLException e) {
            throw new ConnectionException(e.getMessage());
        }
    }

    /**
     * Teste si la table name existe.
     * Dans la base de donnée connectée à conn.
     * @param name Nom de la table
     * @param conn Connexion avec la base de donnée.
     * @return true si elle existe, false sinon
     * @throws MetaDataException En cas d'erreur lors de la lecture des méta
     *         données de la base de donnée.
     */
    private static boolean tableExists(final String name, final Connection conn)
            throws MetaDataException {
        DatabaseMetaData dbmd;
        try {
            dbmd = conn.getMetaData();
            try (ResultSet rs =
                    dbmd.getTables(null, null, name.toUpperCase(), null)) {
                if (rs.next()) {
                    return true;
                }
            }
        } catch (SQLException e) {
            throw new MetaDataException(e.getMessage());
        }
        return false;
    }

    /**
     * Crée la tables utile pour Dessin.
     * C'est à dire : Dessin.
     * @param conn Connexion à la base de donnée
     * @throws CreationTableException En cas d'erreur lors de la creation des
     *         tables.
     */
    static void createTable(final Connection conn)
            throws CreationTableException {
        try {
            if (!tableExists("dessin", conn)) {
                try (Statement stmt = conn.createStatement()) {
                    stmt.execute("Create table dessin ("
                            + "dessinID int primary key "
                            + "GENERATED BY DEFAULT AS IDENTITY,"
                            + "nom varchar(30) not null, "
                            + "globalID int not null, "
                            + "unique (nom, globalID),"
                            + "foreign key (globalID) "
                            + "references dessin(dessinID))");
                }
                try (Statement insertDessin = conn.createStatement()) {
                    insertDessin.execute("INSERT INTO dessin "
                            + "values (-1, 'GLOBAL', -1)");
                }
            }
        } catch (MetaDataException | SQLException e) {
            throw new CreationTableException("dessin", e.getMessage());
        }
    }

    /**
     * Remplit les différentes valeurs du statement préparé.
     * Avec les objects values mis en paramêtre.
     * @param statement PreparedStatement à remplir
     * @param values Valeurs du preparedStatement
     * @throws RemplissageStatementException En cas d'erreur lors du
     *         remplissage.
     */
    public static void remplitStatement(final PreparedStatement statement,
            final Object... values) throws RemplissageStatementException {
        try {
            for (int i = 0; i < values.length; i++) {
                statement.setObject(i + 1, values[i]);
            }
        } catch (SQLException e) {
            throw new RemplissageStatementException(e.getMessage());
        }
    }

    /**
     * Insert l'objet Dessin dans la base de donnée.
     * Insert tout son contenu.
     * Via la connexion conn.
     * @param obj Dessin à insérer
     * @param globalID ID du dessin global auquel le dessin appartient
     * @param conn Connexion à la base de donnée
     * @throws InsertionException En cas d'erreur lors de l'insertion de données
     * @throws CreationTableException En cas d'erreur lors de la creation des
     *         tables
     * @throws DoublonException En cas de duplication de clé, si l'objet obj
     *         existe déjà
     */
    static void insert(final Dessin obj, final int globalID,
            final Connection conn) throws InsertionException,
            CreationTableException, DoublonException {
        try {
            createTable(conn);
            try (PreparedStatement selectDessin = conn.prepareStatement(
                    "SELECT * FROM dessin WHERE nom = ? AND globalID = ?")) {
                remplitStatement(selectDessin, obj.getNom(), globalID);
                try (ResultSet rs = selectDessin.executeQuery()) {
                    if (rs.next()) {
                        throw new DoublonException(obj.getNom());
                    }
                }
            }

            int dessinID = -1;
            try (PreparedStatement insertDessin = conn.prepareStatement(
                    "INSERT INTO dessin (nom, globalID) " + "values (?, ?)",
                    Statement.RETURN_GENERATED_KEYS)) {
                remplitStatement(insertDessin, obj.getNom(), globalID);
                insertDessin.execute();
                try (ResultSet rs = insertDessin.getGeneratedKeys()) {
                    if (rs.next()) {
                        dessinID = rs.getInt(1);
                    } else {
                        System.err.println("Erreur : Clé non générée.");
                    }
                }
            }

            for (ComposantDessin c : obj.getComposantsFils()) {
                if (c instanceof Carre) {
                    CarreDAOJDBC.insert((Carre) c, dessinID, conn);
                } else if (c instanceof Cercle) {
                    CercleDAOJDBC.insert((Cercle) c, dessinID, conn);
                } else if (c instanceof Rectangle) {
                    RectangleDAOJDBC.insert((Rectangle) c, dessinID, conn);
                } else if (c instanceof Triangle) {
                    TriangleDAOJDBC.insert((Triangle) c, dessinID, conn);
                } else if (c instanceof Dessin) {
                    DessinDAOJDBC.insert((Dessin) c, dessinID, conn);
                }
            }
        } catch (SQLException | RemplissageStatementException e) {
            throw new InsertionException(obj.getNom(), e.getMessage());
        }
    }

    /**
     * Créer le dessin obj dans la base de donnée.
     * @param obj Dessin à créer
     * @return le dessin créé
     * @throws CreationObjetException En cas d'erreur à la création de l'objet.
     * @throws DoublonException En cas de duplication de clé, si l'objet obj
     *         existe déjà
     */
    @Override
    public Dessin create(final Dessin obj)
            throws CreationObjetException, DoublonException {
        Dessin result = null;
        try (Connection conn = getConnection()) {
            try {
                conn.setAutoCommit(false);
                insert(obj, -1, conn);
                conn.commit();
                result = obj;
            } catch (SQLException | JDBCException e) {
                conn.rollback();
                throw e;
            } finally {
                conn.setAutoCommit(true);
            }
        } catch (DoublonException e) {
            throw e;
        } catch (JDBCException | SQLException e) {
            throw new CreationObjetException(obj.getNom(), e.getMessage());
        }
        return result;
    }

    /**
     * Lit tous les dessins dans la base de donnée.
     * Dessins appartenant au dessin globalID
     * @param globalID ID du dessin global auquel le dessin appartient
     * @param conn Connection à la base de donnée
     * @return List de Dessins lus
     * @throws LectureException En cas d'erreur lors de la lecture
     * @throws DessinGlobalException Si un dessin est nommé comme le global
     */
    static List<ComposantDessin> readAll(final int globalID,
            final Connection conn)
            throws LectureException, DessinGlobalException {
        ArrayList<ComposantDessin> listeDessin = new ArrayList<>();
        try {
            if (!tableExists("dessin", conn)) {
                return listeDessin;
            }
        } catch (MetaDataException e) {
        }
        try {
            try (PreparedStatement selectDessin = conn.prepareStatement(
                    "SELECT * FROM dessin WHERE globalID = ?")) {
                remplitStatement(selectDessin, globalID);
                try (ResultSet rs = selectDessin.executeQuery()) {
                    while (rs.next()) {
                        Dessin d = new Dessin(rs.getString("nom"));
                        int dessinID = rs.getInt("dessinID");
                        // CARRE
                        d.ajouteTout(CarreDAOJDBC.readAll(dessinID, conn));
                        // CERCLE
                        d.ajouteTout(CercleDAOJDBC.readAll(dessinID, conn));
                        // RECTANGLE
                        d.ajouteTout(RectangleDAOJDBC.readAll(dessinID, conn));
                        // TRIANGLE
                        d.ajouteTout(TriangleDAOJDBC.readAll(dessinID, conn));
                        // DESSIN
                        d.ajouteTout(DessinDAOJDBC.readAll(dessinID, conn));
                        listeDessin.add(d);
                    }
                }
            }
        } catch (SQLException | RemplissageStatementException
                | DejaExistantException e) {
            throw new LectureException("dessins", e.getMessage());
        }
        return listeDessin;
    }

    /**
     * Lit un dessin dans la base de donnée.
     * Dessin accessible par son nom id.
     * @param id Nom du dessin à lire
     * @param globalID ID du dessin global auquel le dessin appartient
     * @param conn Connection à la base de donnée
     * @return Dessin lu
     * @throws LectureException En cas d'erreur lors de la lecture
     * @throws InexistantException Si le dessin id n'existe pas
     * @throws DessinGlobalException Si un dessin est nommé comme le global
     */
    static Dessin read(final String id, final int globalID,
            final Connection conn) throws LectureException, InexistantException,
            DessinGlobalException {
        Dessin d = null;
        try {
            if (!tableExists("dessin", conn)) {
                throw new InexistantException(id);
            }
        } catch (MetaDataException e) {
        }
        try {
            try (PreparedStatement selectDessin = conn.prepareStatement(
                    "SELECT * FROM dessin WHERE nom = ? AND globalID = ?")) {
                remplitStatement(selectDessin, id, globalID);
                try (ResultSet rs = selectDessin.executeQuery()) {
                    if (rs.next()) {
                        d = new Dessin(rs.getString("nom"));
                        int dessinID = rs.getInt("dessinID");
                        // CARRE
                        d.ajouteTout(CarreDAOJDBC.readAll(dessinID, conn));
                        // CERCLE
                        d.ajouteTout(CercleDAOJDBC.readAll(dessinID, conn));
                        // RECTANGLE
                        d.ajouteTout(RectangleDAOJDBC.readAll(dessinID, conn));
                        // TRIANGLE
                        d.ajouteTout(TriangleDAOJDBC.readAll(dessinID, conn));
                        // DESSIN
                        d.ajouteTout(DessinDAOJDBC.readAll(dessinID, conn));
                    } else {
                        throw new InexistantException(id);
                    }
                }
            }
        } catch (SQLException | RemplissageStatementException
                | DejaExistantException e) {
            throw new LectureException(id, e.getMessage());
        }
        return d;
    }

    /**
     * Recherche un dessin global dans la base de donnée.
     * Dessin accessible par son nom id.
     * @param id Nom du dessin recherché
     * @return Dessin lu, null si erreur
     * @throws RechercheException En cas d'erreur lors de la recherche
     * @throws InexistantException Si le dessin id n'existe pas
     */
    @Override
    public Dessin find(final String id)
            throws InexistantException, RechercheException {
        Dessin result = null;
        try (Connection conn = getConnection()) {
            try {
                conn.setAutoCommit(false);
                result = read(id, -1, conn);
                conn.commit();
            } catch (JDBCException | SQLException | DessinGlobalException e) {
                conn.rollback();
                throw e;
            } finally {
                conn.setAutoCommit(true);
            }
        } catch (InexistantException e) {
            throw e;
        } catch (JDBCException | SQLException | DessinGlobalException e) {
            throw new RechercheException(id, e.getMessage());
        }
        return result;
    }

    /**
     * Modifie le dessin dans la base de donnée.
     * Lui assigne ces nouveaux paramètres.
     * Modifie son contenu aussi.
     * Accessible via son nom et l'id de son dessin global.
     * @param obj Carré à modifié
     * @param globalID ID du dessin global auquel le dessin appartient
     * @param conn Connection à la base de donnée
     * @throws InexistantException Si le dessin obj n'existe pas dans la base de
     *         donnée
     * @throws ModificationException En cas d'erreur pendant la modification.
     */
    static void modify(final Dessin obj, final int globalID,
            final Connection conn)
            throws InexistantException, ModificationException {
        try {
            if (!tableExists("dessin", conn)) {
                throw new InexistantException(obj.getNom());
            }
        } catch (MetaDataException e) {
        }
        try {
            try (PreparedStatement selectDessin = conn.prepareStatement(
                    "SELECT * FROM dessin WHERE nom = ? AND globalID = ?")) {
                remplitStatement(selectDessin, obj.getNom(), globalID);
                try (ResultSet rs = selectDessin.executeQuery()) {
                    if (rs.next()) {
                        int dessinID = rs.getInt("dessinID");
                        ArrayList<String> nomsCarre = new ArrayList<>();
                        ArrayList<String> nomsCercle = new ArrayList<>();
                        ArrayList<String> nomsRectangle = new ArrayList<>();
                        ArrayList<String> nomsTriangle = new ArrayList<>();
                        ArrayList<String> nomsDessin = new ArrayList<>();

                        for (ComposantDessin c : obj.getComposantsFils()) {
                            if (c instanceof Carre) {
                                nomsCarre.add(((Carre) c).getNom());
                                try {
                                    CarreDAOJDBC.modify((Carre) c, dessinID,
                                            conn);
                                } catch (InexistantException e) {
                                    CarreDAOJDBC.insert((Carre) c, dessinID,
                                            conn);
                                }
                            } else if (c instanceof Cercle) {
                                nomsCercle.add(((Cercle) c).getNom());
                                try {
                                    CercleDAOJDBC.modify((Cercle) c, dessinID,
                                            conn);
                                } catch (InexistantException e) {
                                    CercleDAOJDBC.insert((Cercle) c, dessinID,
                                            conn);
                                }
                            } else if (c instanceof Rectangle) {
                                nomsRectangle.add(((Rectangle) c).getNom());
                                try {
                                    RectangleDAOJDBC.modify((Rectangle) c,
                                            dessinID, conn);
                                } catch (InexistantException e) {
                                    RectangleDAOJDBC.insert((Rectangle) c,
                                            dessinID, conn);
                                }
                            } else if (c instanceof Triangle) {
                                nomsTriangle.add(((Triangle) c).getNom());
                                try {
                                    TriangleDAOJDBC.modify((Triangle) c,
                                            dessinID, conn);
                                } catch (InexistantException e) {
                                    TriangleDAOJDBC.insert((Triangle) c,
                                            dessinID, conn);
                                }
                            } else if (c instanceof Dessin) {
                                nomsDessin.add(((Dessin) c).getNom());
                                try {
                                    DessinDAOJDBC.modify((Dessin) c, dessinID,
                                            conn);
                                } catch (InexistantException e) {
                                    DessinDAOJDBC.insert((Dessin) c, dessinID,
                                            conn);
                                }
                            }
                        }
                        CarreDAOJDBC.suppressAllBut(nomsCarre.toArray(),
                                dessinID, conn);
                        CercleDAOJDBC.suppressAllBut(nomsCercle.toArray(),
                                dessinID, conn);
                        RectangleDAOJDBC.suppressAllBut(nomsRectangle.toArray(),
                                dessinID, conn);
                        TriangleDAOJDBC.suppressAllBut(nomsTriangle.toArray(),
                                dessinID, conn);
                        DessinDAOJDBC.suppressAllBut(nomsDessin.toArray(),
                                dessinID, conn);
                    } else {
                        throw new InexistantException(obj.getNom());
                    }
                }
            }

        } catch (SQLException | JDBCException e) {
            throw new ModificationException(obj.getNom(), e.getMessage());
        }
    }

    /**
     * Met à jour le dessin dans la base de donnée.
     * Lui assigne ces nouveaux paramètres.
     * Met à jour son contenu aussi.
     * Accessible via son nom.
     * @param obj Dessin à mettre à jour
     * @throws InexistantException Si le dessin obj n'existe pas dans la base de
     *         donnée
     * @throws MisAJourException En cas d'erreur pendant la mise à jour.
     */
    @Override
    public Dessin update(final Dessin obj)
            throws InexistantException, MisAJourException {
        Dessin result = null;
        try (Connection conn = getConnection()) {
            try {
                conn.setAutoCommit(false);
                modify(obj, -1, conn);
                conn.commit();
                result = obj;
            } catch (JDBCException | SQLException e) {
                conn.rollback();
                throw e;
            } finally {
                conn.setAutoCommit(true);
            }
        } catch (InexistantException e) {
            throw e;
        } catch (JDBCException | SQLException e) {
            throw new MisAJourException(obj.getNom(), e.getMessage());
        }
        return result;
    }

    /**
     * Supprime tous les dessin appartenant au dessin globalID.
     * Sauf ceux dont les noms sont dans la liste noms
     * Supprime aussi leur contenu.
     * @param noms Liste de noms de dessin non à supprimer
     * @param globalID ID du dessin global auquel le dessin appartient
     * @param conn Connexion à la base de donnée
     * @throws SuppressionException En cas d'erreur lors de la suppression
     */
    static void suppressAllBut(final Object[] noms, final int globalID,
            final Connection conn) throws SuppressionException {
        try {
            if (tableExists("dessin", conn)) {
                String sql = "SELECT * FROM dessin " + "WHERE globalID = ?";
                for (int i = 0; i < noms.length; i++) {
                    sql = sql.concat(" AND nom <> ?");
                }
                try (PreparedStatement selectDessin =
                        conn.prepareStatement(sql)) {
                    Object[] att = new Object[noms.length + 1];
                    att[0] = globalID;
                    for (int i = 0; i < noms.length; i++) {
                        att[i + 1] = noms[i];
                    }
                    remplitStatement(selectDessin, att);
                    try (ResultSet rs = selectDessin.executeQuery()) {
                        while (rs.next()) {
                            DessinDAOJDBC.suppressWithId(rs.getInt("dessinID"),
                                    conn);
                        }
                    }
                }
            }
        } catch (SQLException | RemplissageStatementException
                | MetaDataException e) {
            throw new SuppressionException("dessins", e.getMessage());
        }
    }

    /**
     * Supprime tous les dessin appartenant au dessin globalID.
     * Supprime aussi son contenu.
     * @param globalID ID du dessin global auquel le dessin appartient
     * @param conn Connexion à la base de donnée
     * @throws SuppressionException En cas d'erreur lors de la suppression
     */
    static void suppressAll(final int globalID, final Connection conn)
            throws SuppressionException {
        try {
            if (tableExists("dessin", conn)) {
                try (PreparedStatement selectDessin = conn.prepareStatement(
                        "SELECT * FROM dessin WHERE globalID = ?")) {
                    remplitStatement(selectDessin, globalID);
                    try (ResultSet rs = selectDessin.executeQuery()) {
                        while (rs.next()) {
                            int dessinID = rs.getInt("dessinID");
                            CarreDAOJDBC.suppressAll(dessinID, conn);
                            CercleDAOJDBC.suppressAll(dessinID, conn);
                            RectangleDAOJDBC.suppressAll(dessinID, conn);
                            TriangleDAOJDBC.suppressAll(dessinID, conn);
                            DessinDAOJDBC.suppressAll(dessinID, conn);
                            try (PreparedStatement deleteDessin =
                                    conn.prepareStatement("DELETE FROM dessin "
                                            + "WHERE dessinID = ?")) {
                                remplitStatement(deleteDessin, dessinID);
                                deleteDessin.execute();
                            }
                        }
                    }
                }
            }
        } catch (SQLException | RemplissageStatementException
                | MetaDataException e) {
            throw new SuppressionException("dessins", e.getMessage());
        }
    }

    /**
     * Supprime le dessin de la base de donnée.
     * Supprime aussi son contenu.
     * Accessible par son id.
     * @param dessinID ID du dessin
     * @param conn Connexion à la base de donnée
     * @throws SuppressionException En cas d'erreur lors de la suppression
     */
    static void suppressWithId(final int dessinID, final Connection conn)
            throws SuppressionException {
        try {
            if (tableExists("dessin", conn)) {
                CarreDAOJDBC.suppressAll(dessinID, conn);
                CercleDAOJDBC.suppressAll(dessinID, conn);
                RectangleDAOJDBC.suppressAll(dessinID, conn);
                TriangleDAOJDBC.suppressAll(dessinID, conn);
                DessinDAOJDBC.suppressAll(dessinID, conn);
                try (PreparedStatement deleteDessin = conn.prepareStatement(
                        "DELETE FROM dessin " + "WHERE dessinID = ?")) {
                    remplitStatement(deleteDessin, dessinID);
                    deleteDessin.execute();
                }
            }
        } catch (SQLException | RemplissageStatementException
                | MetaDataException e) {
            throw new SuppressionException("ID " + dessinID, e.getMessage());
        }
    }

    /**
     * Supprime le dessin obj de la base de donnée.
     * Supprime aussi son contenu.
     * Accessible par son nom et l'id de son dessin.
     * @param id Nom de l'objet à supprimer
     * @param globalID ID du dessin global auquel le dessin appartient
     * @param conn Connexion à la base de donnée
     * @throws SuppressionException En cas d'erreur lors de la suppression
     */
    static void suppress(final String id, final int globalID,
            final Connection conn) throws SuppressionException {
        try {
            if (tableExists("dessin", conn)) {
                try (PreparedStatement selectDessin =
                        conn.prepareStatement("SELECT * FROM dessin "
                                + "WHERE nom = ? AND globalID = ?")) {
                    remplitStatement(selectDessin, id, globalID);
                    try (ResultSet rs = selectDessin.executeQuery()) {
                        if (rs.next()) {
                            int dessinID = rs.getInt("dessinID");
                            CarreDAOJDBC.suppressAll(dessinID, conn);
                            CercleDAOJDBC.suppressAll(dessinID, conn);
                            RectangleDAOJDBC.suppressAll(dessinID, conn);
                            TriangleDAOJDBC.suppressAll(dessinID, conn);
                            DessinDAOJDBC.suppressAll(dessinID, conn);
                            try (PreparedStatement deleteDessin =
                                    conn.prepareStatement("DELETE FROM dessin "
                                            + "WHERE dessinID = ?")) {
                                remplitStatement(deleteDessin, dessinID);
                                deleteDessin.execute();
                            }
                        }
                    }
                }
            }
        } catch (SQLException | RemplissageStatementException
                | MetaDataException e) {
            throw new SuppressionException(id, e.getMessage());
        }
    }

    /**
     * Efface le dessin obj de la base de donnée.
     * Accessible par son nom.
     * @param id Nom de l'objet à effacer
     * @throws DeletionException En cas d'erreur lors de l'effacement
     */
    @Override
    public void delete(final String id) throws DeletionException {
        try (Connection conn = getConnection()) {
            try {
                conn.setAutoCommit(false);
                suppress(id, -1, conn);
                conn.commit();
            } catch (JDBCException | SQLException e) {
                conn.rollback();
                throw e;
            } finally {
                conn.setAutoCommit(true);
            }
        } catch (JDBCException | SQLException e) {
            throw new DeletionException(id, e.getMessage());
        }
    }
}
